#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

#define MAX_INPUT 1024
#define MAX_ARGS 20
#define HISTORY_FILE "history.txt"

struct command {
    char *command;
    char *args[MAX_ARGS];
    int count_args;
};

struct command commands[1024] = {};

void add_to_history(char *command) {
    FILE *file = fopen(HISTORY_FILE, "a");
    if (file != NULL) {
        fprintf(file, "%s\n", command);
        fclose(file);
    }
}

void execute_command_history() {
    FILE *file = fopen(HISTORY_FILE, "r");
    if (file != NULL) {
        char line[MAX_INPUT];
        while (fgets(line, sizeof(line), file) != NULL) {
            printf("%s", line);
        }
        fclose(file);
    }
}

int execute_command(char **input) {
    fflush(stdout);
    pid_t pid = vfork();

    if (pid == 0) {
        // Пробуем execvp для всех команд
        execvp(input[0], input);

        // Если execvp не сработал, пробуем execv для относительных путей
        if (strchr(input[0], '/') != NULL) {
            execv(input[0], input);
        }

        // Если обе попытки не удались, выводим ошибку в stderr
        fprintf(stderr, "Command not found\n");
        _exit(127);
    } else if (pid > 0) {
        int status;
        waitpid(pid, &status, 0);
        return WEXITSTATUS(status);
    } else {
        return -1;
    }
}

int add_command(char *input, int i) {
    char *input_copy = strdup(input);
    char *token = strtok(input_copy, " \n\t\r");

    if (token == NULL) {
        free(input_copy);
        return -1;
    }

    commands[i].command = strdup(token);
    commands[i].args[0] = strdup(token);
    commands[i].count_args = 1;

    int arg_count = 1;
    while ((token = strtok(NULL, " \n\t\r")) != NULL) {
        commands[i].args[arg_count] = strdup(token);
        commands[i].count_args++;
        arg_count++;
    }
    commands[i].args[arg_count] = NULL;

    add_to_history(input);
    free(input_copy);
    return 0;
}

// Функция для обработки интерактивных команд типа cat
void handle_interactive_command(char *command) {
    char *args[MAX_ARGS];
    int i = 0;
    char *token = strtok(command, " \n\t\r");

    while (token != NULL && i < MAX_ARGS - 1) {
        args[i++] = token;
        token = strtok(NULL, " \n\t\r");
    }
    args[i] = NULL;

    if (i > 0) {
        execute_command(args);
    }
}

int parse_command(char *input, char **args) {
    char *input_copy = strdup(input);
    char *save_token;

    if (strcmp(input, "history") == 0) {
        execute_command_history();
        free(input_copy);
        return 0;
    }

    if (strstr(input, "&&") != NULL) {
        char *token = strtok_r(input_copy, "&&", &save_token);
        int i = 0;
        int last_comm_status = 0;
        while (token != NULL) {
            while (*token == ' ') token++;
            char *end = token + strlen(token) - 1;
            while (end > token && *end == ' ') end--;
            *(end + 1) = '\0';

            if (strcmp("history", token) == 0) {
                execute_command_history();
            }

            if (strlen(token) > 0) {
                if (last_comm_status != 0) {
                    break;
                }
                add_command(token, i);
                last_comm_status = execute_command(commands[i].args);
            }

            token = strtok_r(NULL, "&&", &save_token);
            i++;
        }
        free(input_copy);
        return 0;
    } else {
        // Обычная команда без &&
        int i = 0;
        char *token = strtok_r(input_copy, " \n\t\r", &save_token);

        if (token == NULL) {
            free(input_copy);
            return 0;
        }

        while (token != NULL && i < MAX_ARGS - 1) {
            args[i++] = strdup(token);
            token = strtok_r(NULL, " \n\t\r", &save_token);
        }
        args[i] = NULL;

        add_to_history(input);

        int result = execute_command(args);

        for (int j = 0; j < i; j++) {
            free(args[j]);
        }

        free(input_copy);
        return result;
    }
}

int main() {
    char input[MAX_INPUT];

    while (1) {
        if (fgets(input, MAX_INPUT, stdin) == NULL) {
            break;
        } else {
            int i = 0;
            for (i = 0; i < strlen(input); i++) {
                if (input[i] == '\n') {
                    input[i] = '\0';
                    break;
                }
            }
            if (strcmp(input, "e") == 0 || strcmp(input, "exit") == 0 ||
                strcmp(input, "q") == 0 || strcmp(input, "quit") == 0) {
                break;
            }
        }

        char *args[MAX_ARGS];

        if (strlen(input) == 0) {
            continue;
        }

        // Специальная обработка для cat без аргументов
        if (strcmp(input, "cat") == 0) {
            // Для cat без аргументов читаем из stdin и передаем дальше
            char line[MAX_INPUT];
            while (fgets(line, MAX_INPUT, stdin) != NULL) {
                // Убираем перевод строки
                line[strcspn(line, "\n")] = 0;

                // Если пустая строка или Ctrl+D - выходим
                if (strlen(line) == 0) break;

                // Просто выводим строку (как это делает cat)
                printf("%s\n", line);
                fflush(stdout);
            }
        } else {
            parse_command(input, args);
        }
    }

    return 0;
}